<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸªž Mirror Realm - Enhanced Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;900&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        .background-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .mirror-shard {
            position: absolute;
            width: 2px;
            height: 60px;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: float 8s ease-in-out infinite;
            transform-origin: center;
        }

        .floating-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(78,205,196,0.6);
            border-radius: 50%;
            animation: particleFloat 12s linear infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.3; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 0.8; }
        }

        @keyframes particleFloat {
            0% { transform: translateY(100vh) translateX(0px); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateY(-100px) translateX(50px); opacity: 0; }
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            z-index: 2;
        }

        .game-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
        }

        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
            margin-bottom: 10px;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            text-align: center;
            min-width: 80px;
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }

        .game-arena {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            overflow: hidden;
            box-shadow:
                0 0 50px rgba(255,255,255,0.1),
                inset 0 0 50px rgba(255,255,255,0.05);
        }

        .mirror-line {
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            animation: mirrorPulse 2s ease-in-out infinite;
            z-index: 2;
        }

        .mirror-line.horizontal {
            width: 100%;
            height: 3px;
            top: 50%;
            left: 0;
        }

        .mirror-line.vertical {
            width: 3px;
            height: 100%;
            left: 50%;
            top: 0;
        }

        @keyframes mirrorPulse {
            0%, 100% { opacity: 0.4; box-shadow: 0 0 20px rgba(255,255,255,0.3); }
            50% { opacity: 0.9; box-shadow: 0 0 40px rgba(255,255,255,0.6); }
        }

        .player {
            position: absolute;
            width: 22px;
            height: 22px;
            background: radial-gradient(circle, #ff6b6b, #ff8e8e);
            border-radius: 50%;
            box-shadow:
                0 0 20px #ff6b6b,
                0 0 40px #ff6b6b,
                0 0 60px rgba(255,107,107,0.5);
            transition: all 0.08s ease;
            z-index: 6;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .player-reflection {
            position: absolute;
            width: 22px;
            height: 22px;
            background: radial-gradient(circle, #4ecdc4, #6ee0d6);
            border-radius: 50%;
            box-shadow:
                0 0 20px #4ecdc4,
                0 0 40px #4ecdc4,
                0 0 60px rgba(78,205,196,0.5);
            transition: all 0.08s ease;
            z-index: 5;
            opacity: 0.85;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .crystal {
            position: absolute;
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            border-radius: 50%;
            box-shadow:
                0 0 15px #ffd700,
                0 0 30px rgba(255,215,0,0.5);
            animation: crystalFloat 2s ease-in-out infinite;
            z-index: 4;
            border: 2px solid rgba(255,255,255,0.4);
        }

        @keyframes crystalFloat {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.15) rotate(180deg); }
        }

        .crystal.special {
            background: linear-gradient(45deg, #ff1493, #ff69b4);
            box-shadow:
                0 0 15px #ff1493,
                0 0 30px rgba(255,20,147,0.5);
            animation: crystalSpecial 1.5s ease-in-out infinite;
            width: 20px;
            height: 20px;
        }

        @keyframes crystalSpecial {
            0%, 100% { transform: scale(1) rotate(0deg) translateY(0); }
            50% { transform: scale(1.3) rotate(180deg) translateY(-5px); }
        }

        .obstacle {
            position: absolute;
            background: linear-gradient(45deg, #8e44ad, #9b59b6);
            border-radius: 12px;
            box-shadow:
                0 0 15px #8e44ad,
                0 0 30px rgba(142,68,173,0.5);
            z-index: 4;
            transition: all 0.3s ease;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .obstacle.teleporting {
            animation: teleportPulse 1s ease-in-out infinite;
        }

        @keyframes teleportPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }

        .power-up {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: powerUpFloat 2s ease-in-out infinite;
            z-index: 4;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .power-up.speed {
            background: linear-gradient(45deg, #00ff00, #32cd32);
            box-shadow: 0 0 15px #00ff00;
        }

        .power-up.shield {
            background: linear-gradient(45deg, #1e90ff, #87ceeb);
            box-shadow: 0 0 15px #1e90ff;
        }

        .power-up.slow {
            background: linear-gradient(45deg, #ff8c00, #ffd700);
            box-shadow: 0 0 15px #ff8c00;
        }

        @keyframes powerUpFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-12px) rotate(180deg); }
        }

        .player.shielded {
            box-shadow:
                0 0 20px #ff6b6b,
                0 0 40px #ff6b6b,
                0 0 60px rgba(255,107,107,0.5),
                0 0 80px #1e90ff,
                0 0 100px rgba(30,144,255,0.5);
        }

        .collect-particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background: #ffd700;
            border-radius: 50%;
            pointer-events: none;
            animation: collectParticle 1s ease-out forwards;
        }

        @keyframes collectParticle {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0) translateY(-60px);
            }
        }

        .explosion {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,107,107,0.8), transparent);
            animation: explode 0.6s ease-out forwards;
            pointer-events: none;
            z-index: 7;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: rgba(255,255,255,0.8);
            font-size: 0.9rem;
        }

        .control-keys {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .key {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .key:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .game-over-content {
            text-align: center;
            color: white;
            background: rgba(255,255,255,0.1);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(15px);
            animation: fadeInUp 0.5s ease-out;
        }

        @keyframes fadeInUp {
            0% { opacity: 0; transform: translateY(50px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .game-over-title {
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .restart-btn {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            color: white;
            font-family: 'Exo 2', sans-serif;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(78,205,196,0.3);
        }

        .level-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            font-weight: 900;
            color: rgba(255,255,255,0.9);
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
            opacity: 0;
            z-index: 15;
            pointer-events: none;
            text-align: center;
        }

        .level-indicator.show {
            animation: levelShow 2.5s ease-in-out;
        }

        @keyframes levelShow {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .audio-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .audio-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .audio-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        @media (max-width: 900px) {
            .game-arena {
                width: 90vw;
                height: 70vh;
            }
            .game-title {
                font-size: 2rem;
            }
            .game-stats {
                flex-direction: row;
                gap: 8px;
            }
            .stat-item {
                font-size: 0.8rem;
                padding: 6px 10px;
                min-width: 60px;
            }
        }

        .phase-1 { filter: hue-rotate(0deg) brightness(1.1); }
        .phase-2 { filter: hue-rotate(60deg) brightness(1.1); }
        .phase-3 { filter: hue-rotate(120deg) brightness(1.1); }
        .phase-4 { filter: hue-rotate(180deg) brightness(1.1); }
        .phase-5 { filter: hue-rotate(240deg) brightness(1.1); }
        .phase-6 { filter: hue-rotate(300deg) brightness(1.1); }
    </style>
</head>
<body>
    <div class="background-effects" id="backgroundEffects"></div>

    <div class="audio-controls">
        <button class="audio-btn" onclick="toggleMusic()" id="musicBtn">ðŸŽµ ON</button>
        <button class="audio-btn" onclick="toggleSounds()" id="soundBtn">ðŸ”Š ON</button>
    </div>

    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">ðŸªž MIRROR REALM</h1>
            <div class="game-stats">
                <div class="stat-item">
                    <div>FASE</div>
                    <div id="levelDisplay">1</div>
                </div>
                <div class="stat-item">
                    <div>CRISTAIS</div>
                    <div id="scoreDisplay">0</div>
                </div>
                <div class="stat-item">
                    <div>VIDAS</div>
                    <div id="livesDisplay">3</div>
                </div>
                <div class="stat-item">
                    <div>TEMPO</div>
                    <div id="timeDisplay">0:00</div>
                </div>
                <div class="stat-item">
                    <div>COMBO</div>
                    <div id="comboDisplay">x1</div>
                </div>
            </div>
        </div>

        <div class="game-arena" id="gameArena">
            <div class="player" id="player"></div>
        </div>

        <div class="controls">
            <div>Use WASD ou setas â€¢ Colete cristais â€¢ Evite obstÃ¡culos â€¢ Pegue power-ups â€¢ SPACE para dash</div>
            <div class="control-keys">
                <div class="key">W</div>
                <div class="key">A</div>
                <div class="key">S</div>
                <div class="key">D</div>
                <div class="key">SPACE</div>
            </div>
        </div>

        <div class="level-indicator" id="levelIndicator">FASE 1</div>

        <div class="game-over" id="gameOver">
            <div class="game-over-content">
                <div class="game-over-title">ESPELHOS QUEBRADOS!</div>
                <div id="finalScore">Cristais coletados: 0</div>
                <div id="finalLevel">Fase alcanÃ§ada: 1</div>
                <div id="finalTime">Tempo total: 0:00</div>
                <button class="restart-btn" onclick="restartGame()">ðŸ”„ JOGAR NOVAMENTE</button>
            </div>
        </div>
    </div>

    <script>
        let gameState = {
            level: 1,
            score: 0,
            lives: 3,
            isPlaying: true,
            startTime: Date.now(),
            gameTime: 0,
            combo: 1,
            maxCombo: 1,
            player: { x: 100, y: 100 },
            reflections: [],
            crystals: [],
            obstacles: [],
            powerUps: [],
            mirrorConfig: {},
            speed: 4,
            playerEffects: {
                shield: false,
                shieldTime: 0,
                speedBoost: false,
                speedTime: 0,
                slowTime: false,
                slowTimeLeft: 0
            },
            settings: {
                music: true,
                sounds: true,
                volume: 0.2
            },
            lastTeleport: 0,
            teleportInterval: 3500,
            keys: {}
        };

        const levelConfigs = {
            1: {
                mirrors: { horizontal: true, vertical: false },
                crystals: 6,
                obstacles: 3,
                powerUps: 1,
                specialCrystals: 1,
                description: "Espelho Horizontal - InÃ­cio"
            },
            2: {
                mirrors: { horizontal: false, vertical: true },
                crystals: 7,
                obstacles: 4,
                powerUps: 1,
                specialCrystals: 1,
                description: "Espelho Vertical"
            },
            3: {
                mirrors: { horizontal: true, vertical: true },
                crystals: 8,
                obstacles: 5,
                powerUps: 2,
                specialCrystals: 2,
                description: "Espelhos Cruzados"
            },
            4: {
                mirrors: { horizontal: true, vertical: true },
                crystals: 10,
                obstacles: 6,
                powerUps: 2,
                specialCrystals: 2,
                description: "Teleporte Ativo",
                spawnSystem: true
            },
            5: {
                mirrors: { horizontal: true, vertical: true },
                crystals: 12,
                obstacles: 8,
                powerUps: 3,
                specialCrystals: 3,
                description: "Caos dos Espelhos",
                spawnSystem: true
            },
            6: {
                mirrors: { horizontal: true, vertical: true },
                crystals: 15,
                obstacles: 10,
                powerUps: 3,
                specialCrystals: 4,
                description: "Reino Final",
                spawnSystem: true
            }
        };

        const gameArena = document.getElementById('gameArena');
        const player = document.getElementById('player');
        const levelDisplay = document.getElementById('levelDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const comboDisplay = document.getElementById('comboDisplay');
        const levelIndicator = document.getElementById('levelIndicator');
        const gameOver = document.getElementById('gameOver');

        // Audio Context para mÃºsica procedural suave
        let audioContext;
        let musicGain;
        let soundGain;
        let isPlayingMusic = false;

        document.addEventListener('DOMContentLoaded', function() {
            initializeAudio();
            createBackgroundEffects();
            initializeLevel();
            setupControls();
            gameLoop();
        });

        function initializeAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                musicGain = audioContext.createGain();
                soundGain = audioContext.createGain();
                
                musicGain.connect(audioContext.destination);
                soundGain.connect(audioContext.destination);
                
                musicGain.gain.setValueAtTime(gameState.settings.volume * 0.3, audioContext.currentTime);
                soundGain.gain.setValueAtTime(gameState.settings.volume * 0.4, audioContext.currentTime);
                
                if (gameState.settings.music) {
                    startCalmMusic();
                }
            } catch (e) {
                console.log('Audio not supported');
            }
        }

        function startCalmMusic() {
            if (!audioContext || isPlayingMusic) return;
            
            isPlayingMusic = true;
            playAmbientTones();
        }

        function playAmbientTones() {
            if (!audioContext || !gameState.settings.music) return;
            
            const notes = [
                { freq: 220, time: 0, duration: 2 },    // A3
                { freq: 261.63, time: 1.5, duration: 2 }, // C4
                { freq: 329.63, time: 3, duration: 3 }, // E4
                { freq: 293.66, time: 5, duration: 2 }, // D4
                { freq: 246.94, time: 6.5, duration: 2 }, // B3
            ];
            
            notes.forEach(note => {
                setTimeout(() => {
                    if (audioContext && gameState.settings.music) {
                        playTone(note.freq, note.duration, 'sine', musicGain, 0.08);
                    }
                }, note.time * 1000);
            });
            
            setTimeout(() => {
                if (gameState.settings.music) {
                    playAmbientTones();
                }
            }, 12000);
        }

        function playTone(frequency, duration, waveform = 'sine', gainNode = soundGain, volume = 0.2) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            oscillator.connect(gain);
            gain.connect(gainNode);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = waveform;
            
            gain.gain.setValueAtTime(0, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.2);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playSound(type) {
            if (!audioContext || !gameState.settings.sounds) return;
            
            switch (type) {
                case 'collect':
                    playTone(523.25, 0.15, 'sine', soundGain, 0.12);
                    setTimeout(() => playTone(659.25, 0.1, 'sine', soundGain, 0.08), 80);
                    break;
                case 'special':
                    playTone(659.25, 0.2, 'sine', soundGain, 0.15);
                    setTimeout(() => playTone(783.99, 0.15, 'sine', soundGain, 0.12), 100);
                    break;
                case 'powerup':
                    playTone(440, 0.15, 'square', soundGain, 0.1);
                    setTimeout(() => playTone(554.37, 0.15, 'square', soundGain, 0.1), 80);
                    break;
                case 'hit':
                    playTone(130.81, 0.3, 'sawtooth', soundGain, 0.15);
                    break;
                case 'levelup':
                    playTone(523.25, 0.2, 'sine', soundGain, 0.15);
                    setTimeout(() => playTone(659.25, 0.2, 'sine', soundGain, 0.15), 150);
                    setTimeout(() => playTone(783.99, 0.3, 'sine', soundGain, 0.18), 300);
                    break;
            }
        }

        function createBackgroundEffects() {
            const container = document.getElementById('backgroundEffects');
            
            for (let i = 0; i < 35; i++) {
                const shard = document.createElement('div');
                shard.className = 'mirror-shard';
                shard.style.left = Math.random() * 100 + '%';
                shard.style.top = Math.random() * 100 + '%';
                shard.style.animationDelay = Math.random() * 8 + 's';
                shard.style.animationDuration = (8 + Math.random() * 4) + 's';
                shard.style.transform = `rotate(${Math.random() * 360}deg)`;
                container.appendChild(shard);
            }
            
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'floating-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 12 + 's';
                particle.style.animationDuration = (12 + Math.random() * 6) + 's';
                container.appendChild(particle);
            }
        }

        function initializeLevel() {
            const config = levelConfigs[gameState.level] || levelConfigs[6];
            
            clearArena();
            showLevelIndicator();
            setupMirrors(config.mirrors);
            
            gameState.player = { x: 100, y: 100 };
            updatePlayerPosition();
            
            createCrystals(config.crystals, config.specialCrystals || 0);
            createObstacles(config.obstacles);
            createPowerUps(config.powerUps || 0);
            
            gameState.combo = 1;
            gameState.startTime = Date.now();
            
            updateDisplay();
            
            document.body.className = `phase-${Math.min(gameState.level, 6)}`;
            
            playSound('levelup');
        }

        function clearArena() {
            const elements = gameArena.querySelectorAll('.crystal, .obstacle, .mirror-line, .player-reflection, .collect-particle, .explosion, .power-up');
            elements.forEach(el => el.remove());
            gameState.crystals = [];
            gameState.obstacles = [];
            gameState.powerUps = [];
            gameState.reflections = [];
        }

        function showLevelIndicator() {
            const config = levelConfigs[gameState.level] || levelConfigs[6];
            levelIndicator.innerHTML = `FASE ${gameState.level}<br><small style="font-size:0.4em;">${config.description}</small>`;
            levelIndicator.classList.add('show');
            
            setTimeout(() => {
                levelIndicator.classList.remove('show');
            }, 3000);
        }

        function setupMirrors(mirrors) {
            gameState.mirrorConfig = mirrors;
            
            if (mirrors.horizontal) {
                const line = document.createElement('div');
                line.className = 'mirror-line horizontal';
                gameArena.appendChild(line);
            }
            
            if (mirrors.vertical) {
                const line = document.createElement('div');
                line.className = 'mirror-line vertical';
                gameArena.appendChild(line);
            }
            
            createReflections();
        }

        function createReflections() {
            gameState.reflections = [];
            
            if (gameState.mirrorConfig.horizontal) {
                const reflection = document.createElement('div');
                reflection.className = 'player-reflection';
                gameArena.appendChild(reflection);
                gameState.reflections.push({ element: reflection, type: 'horizontal' });
            }
            
            if (gameState.mirrorConfig.vertical) {
                const reflection = document.createElement('div');
                reflection.className = 'player-reflection';
                gameArena.appendChild(reflection);
                gameState.reflections.push({ element: reflection, type: 'vertical' });
            }
            
            if (gameState.mirrorConfig.horizontal && gameState.mirrorConfig.vertical) {
                const reflection = document.createElement('div');
                reflection.className = 'player-reflection';
                gameArena.appendChild(reflection);
                gameState.reflections.push({ element: reflection, type: 'both' });
            }
        }

        function createCrystals(count, specialCount = 0) {
            for (let i = 0; i < count; i++) {
                const crystal = document.createElement('div');
                crystal.className = 'crystal';
                
                let x, y;
                do {
                    x = Math.random() * (gameArena.offsetWidth - 25) + 12;
                    y = Math.random() * (gameArena.offsetHeight - 25) + 12;
                } while (isPositionOccupied(x, y, 50));
                
                crystal.style.left = x + 'px';
                crystal.style.top = y + 'px';
                
                gameArena.appendChild(crystal);
                gameState.crystals.push({ 
                    element: crystal, 
                    x: x, 
                    y: y, 
                    collected: false, 
                    type: 'normal',
                    value: 1
                });
            }
            
            for (let i = 0; i < specialCount; i++) {
                const crystal = document.createElement('div');
                crystal.className = 'crystal special';
                
                let x, y;
                do {
                    x = Math.random() * (gameArena.offsetWidth - 25) + 12;
                    y = Math.random() * (gameArena.offsetHeight - 25) + 12;
                } while (isPositionOccupied(x, y, 50));
                
                crystal.style.left = x + 'px';
                crystal.style.top = y + 'px';
                
                gameArena.appendChild(crystal);
                gameState.crystals.push({ 
                    element: crystal, 
                    x: x, 
                    y: y, 
                    collected: false, 
                    type: 'special',
                    value: 5
                });
            }
        }

        function createObstacles(count) {
            for (let i = 0; i < count; i++) {
                const obstacle = document.createElement('div');
                obstacle.className = 'obstacle';
                
                const width = 30 + Math.random() * 35;
                const height = 30 + Math.random() * 35;
                
                let x, y;
                do {
                    x = Math.random() * (gameArena.offsetWidth - width);
                    y = Math.random() * (gameArena.offsetHeight - height);
                } while (isPositionOccupied(x, y, 80));
                
                obstacle.style.left = x + 'px';
                obstacle.style.top = y + 'px';
                obstacle.style.width = width + 'px';
                obstacle.style.height = height + 'px';
                
                if (gameState.level >= 4) {
                    obstacle.classList.add('teleporting');
                }
                
                gameArena.appendChild(obstacle);
                gameState.obstacles.push({ 
                    element: obstacle, 
                    x: x, 
                    y: y, 
                    width: width, 
                    height: height,
                    canTeleport: gameState.level >= 4
                });
            }
        }

        function createPowerUps(count) {
            const powerUpTypes = ['speed', 'shield', 'slow'];
            
            for (let i = 0; i < count; i++) {
                const powerUp = document.createElement('div');
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                powerUp.className = `power-up ${type}`;
                
                let x, y;
                do {
                    x = Math.random() * (gameArena.offsetWidth - 25) + 12;
                    y = Math.random() * (gameArena.offsetHeight - 25) + 12;
                } while (isPositionOccupied(x, y, 40));
                
                powerUp.style.left = x + 'px';
                powerUp.style.top = y + 'px';
                
                gameArena.appendChild(powerUp);
                gameState.powerUps.push({ 
                    element: powerUp, 
                    x: x, 
                    y: y, 
                    type: type,
                    collected: false
                });
            }
        }

        function isPositionOccupied(x, y, minDistance) {
            const playerDistance = Math.sqrt(Math.pow(x - gameState.player.x, 2) + Math.pow(y - gameState.player.y, 2));
            if (playerDistance < minDistance) return true;
            
            const allObjects = [
                ...gameState.crystals,
                ...gameState.obstacles,
                ...gameState.powerUps
            ];
            
            for (let obj of allObjects) {
                const distance = Math.sqrt(Math.pow(x - obj.x, 2) + Math.pow(y - obj.y, 2));
                if (distance < minDistance) return true;
            }
            
            return false;
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.key.toLowerCase()] = true;
                
                if (e.code === 'Space') {
                    e.preventDefault();
                    activateDash();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.key.toLowerCase()] = false;
            });

            // Click to start audio context
            document.addEventListener('click', () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true });
        }

        function activateDash() {
            if (gameState.playerEffects.speedBoost) {
                const dashDistance = 50;
                let dx = 0, dy = 0;
                
                if (gameState.keys['w'] || gameState.keys['arrowup']) dy = -1;
                if (gameState.keys['s'] || gameState.keys['arrowdown']) dy = 1;
                if (gameState.keys['a'] || gameState.keys['arrowleft']) dx = -1;
                if (gameState.keys['d'] || gameState.keys['arrowright']) dx = 1;
                
                if (dx === 0 && dy === 0) {
                    dx = 1; // Default dash right
                }
                
                const length = Math.sqrt(dx * dx + dy * dy);
                dx /= length;
                dy /= length;
                
                const newX = Math.max(0, Math.min(gameArena.offsetWidth - 22, gameState.player.x + dx * dashDistance));
                const newY = Math.max(0, Math.min(gameArena.offsetHeight - 22, gameState.player.y + dy * dashDistance));
                
                if (!checkObstacleCollision(newX, newY, 22, 22)) {
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                    updatePlayerPosition();
                    createDashEffect();
                    checkCollisions();
                }
            }
        }

        function createDashEffect() {
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'collect-particle';
                particle.style.background = '#00ff00';
                particle.style.left = (gameState.player.x + Math.random() * 30 - 15) + 'px';
                particle.style.top = (gameState.player.y + Math.random() * 30 - 15) + 'px';
                gameArena.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1000);
            }
        }

        function movePlayer(dx, dy) {
            const speed = gameState.playerEffects.speedBoost ? gameState.speed * 1.5 : gameState.speed;
            const newX = Math.max(0, Math.min(gameArena.offsetWidth - 22, gameState.player.x + dx * speed));
            const newY = Math.max(0, Math.min(gameArena.offsetHeight - 22, gameState.player.y + dy * speed));
            
            if (!checkObstacleCollision(newX, newY, 22, 22)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
                updatePlayerPosition();
                checkCollisions();
            }
        }

        function updatePlayerPosition() {
            player.style.left = gameState.player.x + 'px';
            player.style.top = gameState.player.y + 'px';
            
            if (gameState.playerEffects.shield) {
                player.classList.add('shielded');
            } else {
                player.classList.remove('shielded');
            }
            
            gameState.reflections.forEach(reflection => {
                let reflectionX = gameState.player.x;
                let reflectionY = gameState.player.y;
                
                switch (reflection.type) {
                    case 'horizontal':
                        reflectionY = gameArena.offsetHeight - gameState.player.y - 22;
                        break;
                    case 'vertical':
                        reflectionX = gameArena.offsetWidth - gameState.player.x - 22;
                        break;
                    case 'both':
                        reflectionX = gameArena.offsetWidth - gameState.player.x - 22;
                        reflectionY = gameArena.offsetHeight - gameState.player.y - 22;
                        break;
                }
                
                reflection.element.style.left = Math.max(0, Math.min(gameArena.offsetWidth - 22, reflectionX)) + 'px';
                reflection.element.style.top = Math.max(0, Math.min(gameArena.offsetHeight - 22, reflectionY)) + 'px';
            });
        }

        function checkObstacleCollision(x, y, width, height) {
            for (let obstacle of gameState.obstacles) {
                if (x < obstacle.x + obstacle.width &&
                    x + width > obstacle.x &&
                    y < obstacle.y + obstacle.height &&
                    y + height > obstacle.y) {
                    return true;
                }
            }
            return false;
        }

        function checkCollisions() {
            // Crystal collection
            gameState.crystals.forEach((crystal, index) => {
                if (!crystal.collected) {
                    const distance = Math.sqrt(
                        Math.pow(gameState.player.x - crystal.x, 2) +
                        Math.pow(gameState.player.y - crystal.y, 2)
                    );
                    
                    if (distance < 25) {
                        collectCrystal(crystal, index);
                    }
                    
                    // Check reflections
                    gameState.reflections.forEach(reflection => {
                        const rect = reflection.element.getBoundingClientRect();
                        const arenaRect = gameArena.getBoundingClientRect();
                        const reflectionX = rect.left - arenaRect.left;
                        const reflectionY = rect.top - arenaRect.top;
                        
                        const reflectionDistance = Math.sqrt(
                            Math.pow(reflectionX - crystal.x, 2) +
                            Math.pow(reflectionY - crystal.y, 2)
                        );
                        
                        if (reflectionDistance < 25) {
                            collectCrystal(crystal, index);
                        }
                    });
                }
            });
            
            // Power-up collection
            gameState.powerUps.forEach((powerUp, index) => {
                if (!powerUp.collected) {
                    const distance = Math.sqrt(
                        Math.pow(gameState.player.x - powerUp.x, 2) +
                        Math.pow(gameState.player.y - powerUp.y, 2)
                    );
                    
                    if (distance < 25) {
                        collectPowerUp(powerUp, index);
                    }
                }
            });
            
            // Obstacle collision (if not shielded)
            if (!gameState.playerEffects.shield) {
                gameState.reflections.forEach(reflection => {
                    const rect = reflection.element.getBoundingClientRect();
                    const arenaRect = gameArena.getBoundingClientRect();
                    const reflectionX = rect.left - arenaRect.left;
                    const reflectionY = rect.top - arenaRect.top;
                    
                    if (checkObstacleCollision(reflectionX, reflectionY, 22, 22)) {
                        hitObstacle(reflectionX, reflectionY);
                    }
                });
                
                if (checkObstacleCollision(gameState.player.x, gameState.player.y, 22, 22)) {
                    hitObstacle(gameState.player.x, gameState.player.y);
                }
            }
        }

        function collectCrystal(crystal, index) {
            if (crystal.collected) return;
            
            crystal.collected = true;
            crystal.element.style.display = 'none';
            
            const points = crystal.value * gameState.combo;
            gameState.score += points;
            
            if (crystal.type === 'special') {
                gameState.combo = Math.min(gameState.combo + 1, 10);
                if (gameState.combo > gameState.maxCombo) {
                    gameState.maxCombo = gameState.combo;
                }
                playSound('special');
            } else {
                playSound('collect');
            }
            
            updateDisplay();
            createCollectParticles(crystal.x, crystal.y);
            
            const remainingCrystals = gameState.crystals.filter(c => !c.collected);
            if (remainingCrystals.length === 0) {
                nextLevel();
            }
        }

        function collectPowerUp(powerUp, index) {
            if (powerUp.collected) return;
            
            powerUp.collected = true;
            powerUp.element.style.display = 'none';
            
            applyPowerUp(powerUp.type);
            playSound('powerup');
        }

        function applyPowerUp(type) {
            const now = Date.now();
            
            switch (type) {
                case 'speed':
                    gameState.playerEffects.speedBoost = true;
                    gameState.playerEffects.speedTime = now + 8000;
                    break;
                case 'shield':
                    gameState.playerEffects.shield = true;
                    gameState.playerEffects.shieldTime = now + 12000;
                    break;
                case 'slow':
                    gameState.playerEffects.slowTime = true;
                    gameState.playerEffects.slowTimeLeft = now + 6000;
                    gameState.teleportInterval = 6000;
                    break;
            }
        }

        function createCollectParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'collect-particle';
                particle.style.left = (x + Math.random() * 20 - 10) + 'px';
                particle.style.top = (y + Math.random() * 20 - 10) + 'px';
                gameArena.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1000);
            }
        }

        function hitObstacle(x, y) {
            if (gameState.playerEffects.shield) return;
            
            gameState.lives--;
            gameState.combo = 1;
            updateDisplay();
            
            const explosion = document.createElement('div');
            explosion.className = 'explosion';
            explosion.style.left = (x - 40) + 'px';
            explosion.style.top = (y - 40) + 'px';
            gameArena.appendChild(explosion);
            
            setTimeout(() => explosion.remove(), 600);
            playSound('hit');
            
            if (gameState.lives <= 0) {
                endGame();
            } else {
                gameState.player = { x: 100, y: 100 };
                updatePlayerPosition();
            }
        }

        function teleportObstacles() {
            const now = Date.now();
            if (now - gameState.lastTeleport < gameState.teleportInterval) return;
            
            gameState.obstacles.forEach(obstacle => {
                if (obstacle.canTeleport && Math.random() < 0.4) {
                    let newX, newY;
                    do {
                        newX = Math.random() * (gameArena.offsetWidth - obstacle.width);
                        newY = Math.random() * (gameArena.offsetHeight - obstacle.height);
                    } while (isPositionOccupied(newX, newY, 60));
                    
                    obstacle.x = newX;
                    obstacle.y = newY;
                    obstacle.element.style.left = newX + 'px';
                    obstacle.element.style.top = newY + 'px';
                }
            });
            
            gameState.lastTeleport = now;
        }

        function updateEffects() {
            const now = Date.now();
            
            if (gameState.playerEffects.speedBoost && now > gameState.playerEffects.speedTime) {
                gameState.playerEffects.speedBoost = false;
            }
            
            if (gameState.playerEffects.shield && now > gameState.playerEffects.shieldTime) {
                gameState.playerEffects.shield = false;
            }
            
            if (gameState.playerEffects.slowTime && now > gameState.playerEffects.slowTimeLeft) {
                gameState.playerEffects.slowTime = false;
                gameState.teleportInterval = 3500;
            }
        }

        function nextLevel() {
            gameState.level++;
            gameState.speed += 0.2;
            
            setTimeout(() => {
                initializeLevel();
            }, 1500);
        }

        function endGame() {
            gameState.isPlaying = false;
            
            document.getElementById('finalScore').textContent = `Cristais coletados: ${gameState.score}`;
            document.getElementById('finalLevel').textContent = `Fase alcanÃ§ada: ${gameState.level}`;
            document.getElementById('finalTime').textContent = `Tempo total: ${formatTime(gameState.gameTime)}`;
            
            gameOver.style.display = 'flex';
        }

        function restartGame() {
            gameState = {
                level: 1,
                score: 0,
                lives: 3,
                isPlaying: true,
                startTime: Date.now(),
                gameTime: 0,
                combo: 1,
                maxCombo: 1,
                player: { x: 100, y: 100 },
                reflections: [],
                crystals: [],
                obstacles: [],
                powerUps: [],
                mirrorConfig: {},
                speed: 4,
                playerEffects: {
                    shield: false,
                    shieldTime: 0,
                    speedBoost: false,
                    speedTime: 0,
                    slowTime: false,
                    slowTimeLeft: 0
                },
                settings: gameState.settings,
                lastTeleport: 0,
                teleportInterval: 3500,
                keys: {}
            };
            
            gameOver.style.display = 'none';
            document.body.className = 'phase-1';
            initializeLevel();
        }

        function updateDisplay() {
            levelDisplay.textContent = gameState.level;
            scoreDisplay.textContent = gameState.score;
            livesDisplay.textContent = gameState.lives;
            comboDisplay.textContent = `x${gameState.combo}`;
            
            gameState.gameTime = Date.now() - gameState.startTime;
            timeDisplay.textContent = formatTime(gameState.gameTime);
        }

        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function gameLoop() {
            if (gameState.isPlaying) {
                let dx = 0, dy = 0;
                
                if (gameState.keys['w'] || gameState.keys['arrowup']) dy = -1;
                if (gameState.keys['s'] || gameState.keys['arrowdown']) dy = 1;
                if (gameState.keys['a'] || gameState.keys['arrowleft']) dx = -1;
                if (gameState.keys['d'] || gameState.keys['arrowright']) dx = 1;
                
                if (dx !== 0 || dy !== 0) {
                    movePlayer(dx, dy);
                }
                
                updateEffects();
                updateDisplay();
                
                if (gameState.level >= 4) {
                    teleportObstacles();
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        function toggleMusic() {
            gameState.settings.music = !gameState.settings.music;
            const btn = document.getElementById('musicBtn');
            
            if (gameState.settings.music) {
                if (!isPlayingMusic) {
                    startCalmMusic();
                }
                btn.textContent = 'ðŸŽµ ON';
            } else {
                isPlayingMusic = false;
                btn.textContent = 'ðŸŽµ OFF';
            }
        }

        function toggleSounds() {
            gameState.settings.sounds = !gameState.settings.sounds;
            const btn = document.getElementById('soundBtn');
            btn.textContent = gameState.settings.sounds ? 'ðŸ”Š ON' : 'ðŸ”Š OFF';
        }
    </script>
</body>
</html>
